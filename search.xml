<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>并查集</title>
    <url>/2021/05/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2021/05/25/%E5%A0%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆以堆顶分为小根堆和大根堆，堆顶是堆中元素的最小值则是小根堆，反之亦然</p>
<p>以小根堆为例，无论是删除元素，添加元素，<strong>堆都可以保证堆顶是最小值</strong>，</p>
<p>这个性质非常巧妙，比如就可以用它来排序，每次取堆顶即可</p>
<p>要注意的是，堆是以<strong>二叉树</strong>的形式展现的， <strong>父节点是一定小于两个子节点的</strong></p>
<p>而要实现堆这样的性质，只需要两个操作up 和 down操作即可，具体看代码实现</p>
 <span id="more"></span>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用数组h存储堆     <strong>h[0]不存数据 ，h[1]存储根结点</strong></p>
<p>这样实现的好处在于， 对于h[x]， 左子节点为h[2x]，右子节点为h[2x + 1]</p>
<p>用一个变量size(一般也会将其命名为 idx) 表示当前堆的大小（使用的空间）</p>
<blockquote>
<p>堆所要实现的操作</p>
<ol>
<li>插入一个数                    h[size ++] = x; up(size);</li>
<li>求集合中的最小值         min = h[1];</li>
<li>删除最小值                     h[1] = h[size]; size - -; down(1);</li>
<li>删除任意一个元素          h[k] = h[size]; size –; down(k); up(k);</li>
<li>修改任意一个元素          h[k] = x; down(k); up(k);</li>
</ol>
</blockquote>
<p>接下来以模板题为例，实现堆</p>
<p><img src="https://gitee.com/amazing-feather/images/raw/master/20210525211507.png" alt="image-20210525211506960"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//	如果当前不比所有子节点小则下降</span></span><br><span class="line">    <span class="comment">//  x 为 数组下标 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 比较当前 x 与左右子节点的值    临时变量记录最小的节点</span></span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断最小值</span></span><br><span class="line">        <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= size &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t])&#123;</span><br><span class="line">            t = x * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断最小值</span></span><br><span class="line">        <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])&#123;</span><br><span class="line">            t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果t不等于x  说明当前这个x位置的值  不满足均小于左右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(t != x)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[t];</span><br><span class="line">            h[t] = h[x];</span><br><span class="line">            h[x] = s;</span><br><span class="line">            <span class="comment">// 值进行交换之后，父节点一定是最小值</span></span><br><span class="line">            <span class="comment">// 交换前最小值的位置为t，交换后t位置变为更大的值，递归t位置，让以t为根的子树满足结构</span></span><br><span class="line">            down(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  先看down操作，比较详细</span></span><br><span class="line">    <span class="comment">//	如果比父节点的值小则上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 跟down相似，我们可以写出</span></span><br><span class="line">        <span class="keyword">if</span>(x / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[x];</span><br><span class="line">            h[x] = h[x / <span class="number">2</span>];</span><br><span class="line">            h[x / <span class="number">2</span>] = s;</span><br><span class="line">            up(x / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但这里可以有个简化</span></span><br><span class="line">        <span class="comment">// 我们可以观察到如果满足条件只会在调用一次up(x / 2)</span></span><br><span class="line">        <span class="comment">// 而只要有一次不满足条件，后面就不可能再调用</span></span><br><span class="line">        <span class="comment">// 这样我们可以联想到用while循环，如下</span></span><br><span class="line">        <span class="keyword">while</span>(x / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[x];</span><br><span class="line">            h[x] = h[x / <span class="number">2</span>];</span><br><span class="line">            h[x / <span class="number">2</span>] = s;</span><br><span class="line">            <span class="comment">// 每次除2即可</span></span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            h[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">// 每次 down和up 时间复杂度为logn   因为每次只对树的一层进行操作，一共有logn层</span></span><br><span class="line">        <span class="comment">// O(n) 的建堆方式 朴素建堆方式为O(nlogn)</span></span><br><span class="line">        <span class="comment">// 原理自行百度 （我不知道哈哈哈）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每次输出根结点并且删除后继续输出</span></span><br><span class="line">        <span class="keyword">while</span>(m -- != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 输出堆顶</span></span><br><span class="line">            System.out.print(h[<span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除堆顶</span></span><br><span class="line">            h[<span class="number">1</span>] = h[size];</span><br><span class="line">            size --;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时最后的元素放在了堆顶, 只可能下沉</span></span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><blockquote>
<p>饿汉式：类加载的时候就创建出实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">弊端：</span></span><br><span class="line"><span class="comment">即使此单例不需要使用，它也会在类加载后创建出来。占用内存，并增加类的初始化时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的初始化的时候就创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造设为private，防止其他类通过构造方法实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过该静态方法才可获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><blockquote>
<p>懒汉式：先声明一个空变量，需要使用的时候才创建实例</p>
</blockquote>
<p><strong>双检锁方式实现懒汉式单例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重排序使用volatile关键字</span></span><br><span class="line">    <span class="comment">// 重排序会在特殊情况下导致线程不安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证其他类无法通过构造方法创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 不加这个判空，则每次都要加锁，影响性能</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      		<span class="comment">// 加锁保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">                <span class="comment">// 这里不加判空同样可能存在多次创建实例的情况</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类实现懒汉式单例</strong></p>
<p>内部类是在使用时才会加载，所以可以实现懒加载</p>
<p>虚拟机底层是保证了类加载的时候是线程安全的，所以在懒加载创建实例的时候一定是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> StaticLazy instance = <span class="keyword">new</span> StaticLazy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticLazyHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式</p>
<p>对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>最终版抽象工厂模式</strong></p>
<p>总接口，所有的工厂类都必须实现此接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Factory接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供创建实例的方法</span></span><br><span class="line">    <span class="function">Fruit <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂类可以封装（创建类实例时的）细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 苹果工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 封装创建时的具体细节</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这是最终版本的抽象工厂模式</span></span><br><span class="line"><span class="comment">   优点：</span></span><br><span class="line"><span class="comment">   想要修改创建的具体工厂类，只需要改一行代码即可实现，修改之后调用的方法随之改变成对应的工厂实现</span></span><br><span class="line"><span class="comment">   缺点：</span></span><br><span class="line"><span class="comment">   如果Factory接口需要新增功能，会影响到所有具体的工厂类</span></span><br><span class="line"><span class="comment">   所以只适合增加同类具体工厂，而不适合新增功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建苹果</span></span><br><span class="line"> Factory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"><span class="comment">// 直接调用接口提供的方法，不用知道具体细节</span></span><br><span class="line"> Fruit apple = appleFactory.create();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建梨子</span></span><br><span class="line"> Factory pearFactory = <span class="keyword">new</span> PearFactory();</span><br><span class="line"><span class="comment">// 直接调用接口提供的方法，不用知道具体细节</span></span><br><span class="line"> Fruit peat = pearFactory.create();</span><br></pre></td></tr></table></figure>

<h2 id="建造型模式"><a href="#建造型模式" class="headerlink" title="建造型模式"></a>建造型模式</h2><p>建造型模式用于创建过程稳定，但配置多变的对象</p>
<p><strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示</strong></p>
<p>好处在于不会忘记指定配置，保证构建的过程是稳定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 口味类型</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="comment">// 大杯 中杯</span></span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">    <span class="comment">// 是否加珍珠</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> pearl;</span><br><span class="line">    <span class="comment">// 是否加冰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPearl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pearl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MilkTea</span><span class="params">(MilkTeaBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = builder.type;</span><br><span class="line">        <span class="keyword">this</span>.size = builder.size;</span><br><span class="line">        <span class="keyword">this</span>.pearl = builder.pearl;</span><br><span class="line">        <span class="keyword">this</span>.ice = builder.ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MilkTea&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;type=&#x27;&quot;</span> + type + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, size=&#x27;&quot;</span> + size + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pearl=&quot;</span> + pearl +</span><br><span class="line">                <span class="string">&quot;, ice=&quot;</span> + ice +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建造者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTeaBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> String size;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> pearl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MilkTeaBuilder</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">size</span><span class="params">(String size)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">pearl</span><span class="params">(<span class="keyword">boolean</span> pearl)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pearl = pearl;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">ice</span><span class="params">(<span class="keyword">boolean</span> ice)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ice = ice;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTea <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MilkTea(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户建造一杯奶茶</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MilkTea milkTea = <span class="keyword">new</span> MilkTea.MilkTeaBuilder(<span class="string">&quot;蓝莓味&quot;</span>)</span><br><span class="line">    .size(<span class="string">&quot;大杯&quot;</span>)</span><br><span class="line">    .pearl(<span class="keyword">true</span>)</span><br><span class="line">    .ice(<span class="keyword">false</span>)</span><br><span class="line">    .Builder();</span><br><span class="line">System.out.println(milkTea);</span><br></pre></td></tr></table></figure>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>其实就是给对象提供一个clone方法克隆出新对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 口味类型</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="comment">// 是否加冰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    克隆当前实例</span></span><br><span class="line"><span class="comment">    ps： 如下重写clone方法是无法克隆非基本类型的（会直接引用当前的）（浅拷贝），需要自行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MilkTea <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MilkTea) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
