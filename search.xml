<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论</title>
      <link href="2021/11/07/%E5%9B%BE%E8%AE%BA/"/>
      <url>2021/11/07/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>这里是图论 </p><span id="more"></span><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><h3 id="边权均为整数"><a href="#边权均为整数" class="headerlink" title="边权均为整数"></a>边权均为整数</h3><h4 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h4><p><strong>O(n^2^)，适合稠密图</strong></p><p>用邻接矩阵来存</p><blockquote><p>步骤</p><ul><li>在当前所有没有被确定最短路的点中寻找值最小的点t</li><li>直接确定 t 这个点已经为最短路</li><li>更新 t 的所有出边</li></ul><p>细节问题</p><p>不要一开始就将f[1]设为true，因为还需要第一个点的路径去延展其他的路径点</p><p>0x3f3f3f3f的选取（不会溢出，数量级与0x7f7f7f7f（整型最大值）等同）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 贪心 由当前存在的最小值可以确定这个最小值一定为一条最短路，用t记录这个最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t == n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记 t下标 已经确定最短路</span></span><br><span class="line">            f[t] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 由已确定的 t 下标延伸路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> nn = sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        n = nn;</span><br><span class="line">        f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        g = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            dist[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                g[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        <span class="keyword">while</span>(m -- != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = sc.nextInt(), j = sc.nextInt(), x = sc.nextInt();</span><br><span class="line">            g[i][j] = Math.min(g[i][j], x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(dijkstra());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h4><p><strong>O(mlogn)，适合稀疏图</strong></p><p>图用邻接表来存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// h数组（表头需要初始化为-1）存能到的边的实际下标  e存的是实际下标的对应顶点值   ne是一条边，代表a可以到b   w是存 a 到 b的权值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N], w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        w[idx] = x;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化邻接表数组和dist</span></span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//起始点赋值0</span></span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存顶点的编号，对应的当前最小距离</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((Comparator.comparingInt(o -&gt; o[<span class="number">0</span>])));</span><br><span class="line">        heap.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(heap.size() != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 贪心确定 t下标的最短路</span></span><br><span class="line">            <span class="keyword">int</span>[] pair = heap.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> distance = pair[<span class="number">0</span>], t = pair[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果已经确定了，说明是冗余的边，直接下一次循环即可</span></span><br><span class="line">            <span class="keyword">if</span>(f[t])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记 t下标 已经确定最短路</span></span><br><span class="line">            f[t] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由已确定的 t 下标延伸路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">                <span class="comment">// h[t]指向的是实际下标，e存的是实际下标上的顶点值，所以j是顶点的编号，i只是实际下标</span></span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                    dist[j] = distance + w[i];</span><br><span class="line">                &#125;</span><br><span class="line">                heap.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), x = sc.nextInt();</span><br><span class="line">            add(a, b, x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dijkstra());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h3><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p><strong>O(nm)</strong></p><p>c++可用结构体数组存图，这里java用二维数组代替（第二维为常量）</p><blockquote><p>步骤：</p><ul><li><p>先遍历n次（实际意义为第一个点开始，经过不超过n条边，到达每个点的最短路）</p></li><li><p>内层遍历所有的边</p></li><li><p>每次遍历取最小值</p></li></ul></blockquote><p>注意：两层循环之间要备份dist数组，每次遍历的边只能使用上一次的第一重大循环的dist结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N], backup = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] edge = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dist初始化</span></span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 备份dist数组 这里复制n个结果会出错，原因目前不清楚</span></span><br><span class="line">            System.arraycopy(dist, <span class="number">0</span>, backup, <span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//backup = Arrays.copyOf(dist, M);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = edge[j][<span class="number">0</span>], b = edge[j][<span class="number">1</span>], w = edge[j][<span class="number">2</span>];</span><br><span class="line">                dist[b] = Math.min(dist[b], backup[a] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), w = sc.nextInt();</span><br><span class="line">            edge[i][<span class="number">0</span>] = a;</span><br><span class="line">            edge[i][<span class="number">1</span>] = b;</span><br><span class="line">            edge[i][<span class="number">2</span>] = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = bf();</span><br><span class="line">        <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h4><p><strong>一般O(m)，最坏（O(nm)</strong></p><blockquote><p> 在bf算法的基础上进行优化，我们发现在bf算法中，只有dist[a]发生了改变，下一次的dist[b]才会发生改变</p><p> 所以我们可以对此优化，仅对被更新了的元素进行出边操作，更新它的出边，我们可以使用任意数据结构存储，一般使用队列</p><p> 步骤</p><p> 初始化之后直接将一个点加入队列</p><p> 然后开始循环，先弹出队头，再更新队头的出边，更新时，只有被更新了的出边连接的点才加入到队列</p><p> 注意：要用一个布尔数组记录点是否被加入到了队列中，防止队列中出现重复，每次弹出和加入都要更新布尔数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// h数组（表头需要初始化为-1）存能到的边的实际下标  e存的是实际下标的对应顶点值   ne是一条边，代表a可以到b   w是存 a 到 b的权值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N], w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记是否存在于队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        w[idx] = x;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spfa</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化dist</span></span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        f[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">            f[t] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由已确定的 t 下标延伸路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">                <span class="comment">// h[t]指向的是实际下标，e存的是实际下标上的顶点值，所以j是顶点的编号，i只是实际下标</span></span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                    dist[j] = dist[t] + w[i];</span><br><span class="line">                    <span class="comment">// 只有被更新了的点才会被加到队列当中</span></span><br><span class="line">                    <span class="keyword">if</span>(!f[j])&#123;</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                        f[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), x = sc.nextInt();</span><br><span class="line">            add(a, b, x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = spfa(); </span><br><span class="line">        <span class="keyword">if</span>(x == -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spfa判断负环"><a href="#Spfa判断负环" class="headerlink" title="Spfa判断负环"></a>Spfa判断负环</h4><blockquote><p>用一个cnt数组记录每个点当前最小值经过的边数</p><p>如果边数大于等于 n 说明有的边经过了两次，则肯定有负环</p><p>注意：</p><ul><li>不用初始化dist数组</li><li>队列的初始化要将所有的点全部加入进去，因为可能第一个点到不了负环</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// h数组（表头需要初始化为-1）存能到的边的实际下标  e存的是实际下标的对应顶点值   ne是一条边，代表a可以到b   w是存 a 到 b的权值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N], w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记是否存在于队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        w[idx] = x;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spfa</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">            f[t] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由已确定的 t 下标延伸路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">                <span class="comment">// h[t]指向的是实际下标，e存的是实际下标上的顶点值，所以j是顶点的编号，i只是实际下标</span></span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                    dist[j] = dist[t] + w[i];</span><br><span class="line">                    cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[j] &gt;= n)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 只有被更新了的点才会被加到队列当中</span></span><br><span class="line">                    <span class="keyword">if</span>(!f[j])&#123;</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                        f[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), x = sc.nextInt();</span><br><span class="line">            add(a, b, x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(spfa())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p><strong>O(n^3^)，基于动态规划</strong></p><blockquote><p>d是邻接矩阵存图</p><p>注意：判断是否存在路径与bf相似    <strong>d[i][j] &gt; 0x3f3f3f3f / 2</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">           d[i][j] = Math.max(d[i][k], d[k][j]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p><strong>O(n^2^)，类似于dijkstra，适合于稠密图</strong></p><blockquote><p>dist存的是每个点到当前集合的最短距离</p><p>当i为0时，dist[t] 一定是INF，是不用加入到结果的,因为是从这个点开始生成树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这个dist存的是到当前集合的最短距离</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">// 邻接矩阵存图</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记点是否在集合中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化距离</span></span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 找到当前离集合最近的点</span></span><br><span class="line">            <span class="keyword">int</span> t= -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果除第一个加进来的之外的点的最小值是INF,</span></span><br><span class="line">            <span class="comment">// 说明当前集合与其他点不连通，则无生成树</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; dist[t] == INF)&#123;</span><br><span class="line">                <span class="keyword">return</span> INF;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 累加路径和</span></span><br><span class="line">            <span class="comment">// 第一趟加入的点是任意的，</span></span><br><span class="line">            <span class="comment">// 当i为0时，dist[t] 一定是INF，是不用加入进来的,因为是从这个点开始生成树</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                res += dist[t];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记t已经在被加入了集合</span></span><br><span class="line">             f[t] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 由点t去更新其他最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                dist[j] = Math.min(dist[j], g[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">                g[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(),b = sc.nextInt(), x = sc.nextInt();</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// 无向图，重边取最短</span></span><br><span class="line">            g[a][b] = Math.min(g[a][b], x);</span><br><span class="line">            g[b][a] = Math.min(g[a][b], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = prim();</span><br><span class="line">        <span class="keyword">if</span>(t == INF) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><p><strong>O(mlogm)，常数很小，实际效果较好</strong></p><p>步骤</p><ul><li>先按边的权重给边排序</li><li>枚举每条边，判断两个点是否在同一集合</li><li>如果不在同一集合，合并两个点，将边加入生成树</li><li>如果合并次数小于n - 1，说明有边与其他边不连通，即无生成树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 邻接矩阵存图</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到点的集合编号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] != i)&#123;</span><br><span class="line">            p[i] = find(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(),b = sc.nextInt(), w = sc.nextInt();</span><br><span class="line">            g[i][<span class="number">0</span>] = a;</span><br><span class="line">            g[i][<span class="number">1</span>] = b;</span><br><span class="line">            g[i][<span class="number">2</span>] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// kruskal</span></span><br><span class="line">        <span class="comment">// 按权重给边排序</span></span><br><span class="line">        Arrays.sort(g, <span class="number">0</span>, m, (Comparator.comparingInt(o -&gt; o[<span class="number">2</span>])));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = g[i][<span class="number">0</span>], b = g[i][<span class="number">1</span>], w = g[i][<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果a b不连通即不在同一集合中，合并a,b </span></span><br><span class="line">            a = find(a);</span><br><span class="line">            b = find(b);</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                p[a] = b;</span><br><span class="line">                res += w;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并的边数一定是n - 1条</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="top排序"><a href="#top排序" class="headerlink" title="top排序"></a>top排序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>统计每个点的入度</p><p>一开始将所有入度为0的点加入队列</p><p>而后每次弹出队头，枚举每条出边，使出边的点入度减一</p><p>如果入度等于0了，则加入队列</p><p>直至队空，top序即加入队列的顺序</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210604174503.png" alt="image-20210604174503897"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[M], ne = <span class="keyword">new</span> <span class="keyword">int</span>[M]; </span><br><span class="line">    <span class="comment">// 每个点的入度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt();</span><br><span class="line">            add(a,b);</span><br><span class="line">            d[b] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                res[size ++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                d[j] --;</span><br><span class="line">                <span class="keyword">if</span>(d[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(j);</span><br><span class="line">                    res[size ++] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size != n)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">            System.out.print(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h2><p><strong>O(n + m)，邻接表存图</strong></p><blockquote><p>为每一个点染1，然后深搜，延展出去的点如果没有染过就染成2</p><p>如果染过，判断是否是不同，如果发现一条边上的两个点染的同一个值，说明不是二分图</p><p>每个点都会继续延展</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>, n, m;</span><br><span class="line">    <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[M], ne = <span class="keyword">new</span> <span class="keyword">int</span>[M], h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx;</span><br><span class="line">        idx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        color[x] = c;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(color[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(j, <span class="number">3</span> - c))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[j] == c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(),b = sc.nextInt();</span><br><span class="line">            add(a,b);</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(i, <span class="number">1</span>))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><blockquote><p><del>绿帽算法</del></p><p>用于寻找二分图的最大匹配，邻接表存图</p></blockquote><p><strong>O(nm)，实际运行时间远小于O(nm)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n1, n2, m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[M], ne = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储左端点匹配的右端点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] match = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="comment">// 女生没有搜索过</span></span><br><span class="line">            <span class="keyword">if</span>(!f[j])&#123;</span><br><span class="line">                f[j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 女生没有配对 或者 可以让女生已经配对的点换一个对象</span></span><br><span class="line">                <span class="keyword">if</span>(match[j] == <span class="number">0</span> || find(match[j]))&#123;</span><br><span class="line">                    <span class="comment">// 配对</span></span><br><span class="line">                    match[j] = x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n1 = sc.nextInt();</span><br><span class="line">        n2 = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt();</span><br><span class="line">            add(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++)&#123;</span><br><span class="line">            Arrays.fill(f, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(find(i))&#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="2021/11/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>2021/11/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p> 基础算法</p><span id="more"></span><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>分治思想，每次选取一个数x，在数组中随意选（一般选取中点会好一点）</p><p>通过交换让数组 <strong>左边部分全部小于等于x，右边部分全部大于等于x</strong></p><p>再将 <strong>左边部分和右边部分递归</strong> 上述过程，当递归完成时，数组也排好序了</p><p><strong>注意点</strong></p><p>每次i和j交换后都应该先往后跳一步<br>当交换的两个数等于选取的分界数x时，将出现死循环</p><p><strong>i，j的初始化</strong></p><p>执行前要将i，j往外扩展一位</p><p>使得第一次执行后 i，j指向目标位置（即当前数组的首尾）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = arr[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">           <span class="keyword">while</span>(arr[++ i] &lt; x);</span><br><span class="line">           <span class="keyword">while</span>(arr[-- j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归排序左右两边</span></span><br><span class="line">        quickSort(arr, l, j);</span><br><span class="line">        quickSort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>经典的分治思想</p><p>将问题<strong>分</strong>成一些小的问题然后递归求解，<strong>治</strong>则是将分的阶段得到的各答案归并在一起</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line">    <span class="comment">// arr原数组tmp辅助数组 用于双指针比较时存入数据</span></span><br><span class="line">    <span class="comment">// 双指针是分别指向左边数组头 和 右边数组头 依次比较 小的存入tmp</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[N], tmp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">           arr[i] = sc.nextInt();</span><br><span class="line">       &#125;</span><br><span class="line">       merge_sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">           System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// l是左边界 r是右边界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先递归分解</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(arr, l, mid);</span><br><span class="line">        merge_sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的递归完成说明左右两边已经排序完成</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次比较小的数存入tmp</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                tmp[k ++] = arr[i ++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k ++] = arr[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将剩余的数全部放入tmp数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            tmp[k ++] = arr[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">            tmp[k ++] = arr[j ++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将辅助数据已经排序赋值给原数组</span></span><br><span class="line">        <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++)&#123;</span><br><span class="line">            arr[i] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><blockquote><p>给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 表示 以 i 结尾的最长连续不重复子序列的长度</span></span><br><span class="line">    <span class="comment">// j 表示左指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">// 动态存储值的数量</span></span><br><span class="line">        hash[arr[i]] ++;</span><br><span class="line">        <span class="comment">// 因为上一次的i 和 j 已经满足连续不重复子序列</span></span><br><span class="line">        <span class="comment">// 所以如果在 i ++ 之后出现重复则一定是arr[i]重复了</span></span><br><span class="line">        <span class="comment">// 为了不重复，而且 i 已经固定, 只能将 j 后移</span></span><br><span class="line">        <span class="keyword">while</span>(hash[arr[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            hash[arr[j]] --;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, i - j + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 注意每个i结束时不需要更新j</span></span><br><span class="line">        <span class="comment">// 因为已经是最长连续不重复子序列了， 往前更新j是必定会有重复的</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h3><blockquote><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。</p><p>数组下标从 0 开始。</p><p>请你求出满足 A[i]+B[j]=x 的数对 (i,j)。</p><p>数据保证有唯一解。</p></blockquote><p>注意单调性</p><p>i 从 A 数组的最前面开始往后走</p><p>当 i 往后走时，j 只能往前走，所以 j 是从 B 数组的最后面开始走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n + m)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x)&#123;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x)&#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>kmp是一种高效的字符串匹配算法，高效的同时也难理解</p><p>我们要抓住一个点，如何优化暴力匹配</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>暴力匹配是容易的</p><p><strong>用s数组存储长串，长度为m，p数组存储短串（模板串），长度为n, 下标均从1开始存储（习惯）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != p[j])&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有flag没有被赋成false，才说明完全匹配成功</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是暴力做法，暴力在哪呢，暴力在无论每次匹配后是成功还是失败，都会从下一个坐标完全从0开始匹配！</p><p>KMP就是在这里可以做优化</p><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210527222847.png" alt="image-20210527222847146"></p><p>那么如何预处理出next数组，核心是    <strong>自己与自己匹配</strong></p><p>代码实现中可以先看在next数组已经求出来的情况下正常的长短串匹配的过程</p><p>理解上面的之后可以对比着理解 <strong>如何求出next数组</strong></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求next数组(i == 1时就只能从0开始)(自己匹配自己，每次循环有点像dp)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="comment">//如果一直匹配不到就一直回退，知道匹配成功或者回退到0</span></span><br><span class="line">    <span class="keyword">while</span>(j != <span class="number">0</span> &amp;&amp; p[j + <span class="number">1</span>] != p[i])&#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果匹配成功,j就加一（因为j是错了一位的，加上1才应该是回退的点，回退的这个点是匹配成功的最后一个字符，由于错了一位，之后回退后，再次匹配就刚好是从这个最后一位成功的下一位开始匹配判断）</span></span><br><span class="line">    <span class="comment">//如果不成功,则说明j已经等于0了,后面给next赋值时就是赋0，说明这一位回退就意味着重新匹配</span></span><br><span class="line">    <span class="keyword">if</span>(p[j + <span class="number">1</span>] == p[i])&#123;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将j赋值给对应next</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kmp匹配过程</span></span><br><span class="line"><span class="comment">//注意：ss为长串,i为长串匹配时的下标（用数组存的,下标从1开始）,m是长串长度</span></span><br><span class="line"><span class="comment">//注意：ps为短串,j为短串匹配时的下标（用数组存的,下标从1开始）（但是初始化为0，每次比较p[j + 1] 和s[i]）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">    <span class="comment">//如果j没有回退到起点，而且后面一位的匹配失败，那么就回退</span></span><br><span class="line">    <span class="comment">//直到匹配成功或者回退到原点（重新开始匹配）</span></span><br><span class="line">    <span class="keyword">while</span>(j != <span class="number">0</span> &amp;&amp; p[j + <span class="number">1</span>] != s[i])&#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果匹配成功就直接j++,由于每次循环i都会自增，所以此时不需要i++</span></span><br><span class="line">    <span class="keyword">if</span>(p[j + <span class="number">1</span>] == s[i])&#123;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">        <span class="comment">//匹配成功，输出（输出结果看每道题的要求）</span></span><br><span class="line">        System.out.print(i - n + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//回退，寻找下一个匹配的点</span></span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>堆以堆顶分为小根堆和大根堆，堆顶是堆中元素的最小值则是小根堆，反之亦然</p><p>以小根堆为例，无论是删除元素，添加元素，<strong>堆都可以保证堆顶是最小值</strong></p><p>这个性质非常巧妙，比如就可以用它来排序，每次取堆顶即可</p><p>要注意的是，堆是以<strong>二叉树</strong>的形式展现的， <strong>父节点是一定小于两个子节点的</strong></p><p>而要实现堆这样的性质，只需要两个操作up 和 down操作即可，具体看代码实现</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>用数组h存储堆     <strong>h[0]不存数据 ，h[1]存储根结点</strong></p><p>这样实现的好处在于， 对于h[x]， 左子节点为h[2x]，右子节点为h[2x + 1]</p><p>用一个变量size(一般也会将其命名为 idx) 表示当前堆的大小（使用的空间）</p><blockquote><p>堆所要实现的操作</p><ol><li>插入一个数                    h[size ++] = x; up(size);</li><li>求集合中的最小值         min = h[1];</li><li>删除最小值                     h[1] = h[size]; size - -; down(1);</li><li>删除任意一个元素          h[k] = h[size]; size –; down(k); up(k);</li><li>修改任意一个元素          h[k] = x; down(k); up(k);</li></ol></blockquote><p>接下来以模板题为例，实现堆</p><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210525211507.png" alt="image-20210525211506960"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前不比所有子节点小则下降</span></span><br><span class="line">    <span class="comment">//  x 为 数组下标 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 比较当前 x 与左右子节点的值    临时变量记录最小的节点</span></span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断最小值</span></span><br><span class="line">        <span class="keyword">if</span>(x * <span class="number">2</span> &lt;= size &amp;&amp; h[x * <span class="number">2</span>] &lt; h[t])&#123;</span><br><span class="line">            t = x * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断最小值</span></span><br><span class="line">        <span class="keyword">if</span>(x * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[x * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])&#123;</span><br><span class="line">            t = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果t不等于x  说明当前这个x位置的值  不满足均小于左右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(t != x)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[t];</span><br><span class="line">            h[t] = h[x];</span><br><span class="line">            h[x] = s;</span><br><span class="line">            <span class="comment">// 值进行交换之后，父节点一定是最小值</span></span><br><span class="line">            <span class="comment">// 交换前最小值的位置为t，交换后t位置变为更大的值，递归t位置，让以t为根的子树满足结构</span></span><br><span class="line">            down(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  先看down操作，比较详细</span></span><br><span class="line">    <span class="comment">//如果比父节点的值小则上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 跟down相似，我们可以写出</span></span><br><span class="line">        <span class="keyword">if</span>(x / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[x];</span><br><span class="line">            h[x] = h[x / <span class="number">2</span>];</span><br><span class="line">            h[x / <span class="number">2</span>] = s;</span><br><span class="line">            up(x / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但这里可以有个简化</span></span><br><span class="line">        <span class="comment">// 我们可以观察到如果满足条件只会在调用一次up(x / 2)</span></span><br><span class="line">        <span class="comment">// 而只要有一次不满足条件，后面就不可能再调用</span></span><br><span class="line">        <span class="comment">// 这样我们可以联想到用while循环，如下</span></span><br><span class="line">        <span class="keyword">while</span>(x / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[x] &lt; h[x / <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> s = h[x];</span><br><span class="line">            h[x] = h[x / <span class="number">2</span>];</span><br><span class="line">            h[x / <span class="number">2</span>] = s;</span><br><span class="line">            <span class="comment">// 每次除2即可</span></span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            h[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">// 每次 down和up 时间复杂度为logn   因为每次只对树的一层进行操作，一共有logn层</span></span><br><span class="line">        <span class="comment">// O(n) 的建堆方式 朴素建堆方式为O(nlogn)</span></span><br><span class="line">        <span class="comment">// 原理自行百度 （我不知道哈哈哈）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每次输出根结点并且删除后继续输出</span></span><br><span class="line">        <span class="keyword">while</span>(m -- != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 输出堆顶</span></span><br><span class="line">            System.out.print(h[<span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除堆顶</span></span><br><span class="line">            h[<span class="number">1</span>] = h[size];</span><br><span class="line">            size --;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此时最后的元素放在了堆顶, 只可能下沉</span></span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p><strong>ps：讲解等待更新，先贴模板</strong></p><h2 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title="Trie字符串统计"></a>Trie字符串统计</h2><blockquote><p>维护一个字符串集合，支持两种操作</p><ol><li><code>I x</code> 向集合中插入一个字符串 x</li><li><code>Q x</code> 询问一个字符串在集合中出现了多少次</li></ol><p>共有 N 个操作，输入的字符串总长度不超过 100000，字符串仅包含小写英文字母</p></blockquote> <!-- more --><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向最后一次被创建的空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// son[p][u] 表示 p 这个字符的下一个字符 u 的节点位置  u可以取到0-25</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] son = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 指向一开始的空节点</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i ++)&#123;</span><br><span class="line">        <span class="comment">// 字符映射</span></span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 如果不存在,就创建</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)&#123;</span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让p往后走一步</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环结束, p 指向字符串最后一个字符所在的位置</span></span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h2><blockquote><p>在给定的 N 个整数 A1，A2，……，AN中选出两个进行 异或运算，得到的结果最大是多少？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] son = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3100000</span>][<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)&#123;</span><br><span class="line">                son[p][u] = ++ idx;</span><br><span class="line">            &#125;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果更大的一边能走就走，不能走就只能走另外一条</span></span><br><span class="line">            <span class="keyword">if</span>(son[p][<span class="number">1</span> - u] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 相当于将存的数值左移加上最后一位 最后一定会变成一个31位整数</span></span><br><span class="line">                res = res * <span class="number">2</span> + <span class="number">1</span> - u;</span><br><span class="line">                p = son[p][<span class="number">1</span> - u];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 相当于将存的数值左移加上最后一位 最后一定会变成一个31位整数</span></span><br><span class="line">                res = res * <span class="number">2</span> + u;</span><br><span class="line">                p = son[p][u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">            a[i] = sc.nextInt();</span><br><span class="line">            insert(a[i]);</span><br><span class="line">            max = Math.max(max, query(a[i]) ^ a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中</li></ul><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>每个集合用树来表示，树根的编号就是整个集合的编号</p><p>每个节点存储父节点的位置，p[x] 表示 x 的父节点的下标</p><p>当 x = p[x] 时，说明当前节点就是树根，值也就是集合编号</p><p><strong>路径压缩</strong></p><p>对于任意一个元素 x ，在一层一层查找其父节点时，直接让路径上的所有点直接指向树根，让查找的时间复杂度降低至O(1)，总体上近似O(1)</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.如何判断树根</p><p><strong>if (p[x] == x)</strong></p><p>2.如何求 x 的集合编号</p><p><strong>while (p[x] != x) x = p[x]</strong></p><p>3.如何合并两个集合</p><p>假如已经找到了树根    <strong>p[x] 是 x 的集合编号，p[y] 是 y 的集合编号</strong></p><p>合并操作 : <strong>p[x] = y</strong></p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210527084012.png" alt="image-20210527084012105"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原题链接:https://www.acwing.com/problem/content/838/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放每个值的集合编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    <span class="comment">// 存放当前集合的元素数量（每次合并只更改根结点也就是对应集合编号的点的值）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] size = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">    <span class="comment">// 对给定数a 求a所在的集合的元素数量 --&gt; size[find(a)]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find函数 找到元素的集合编号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 路径压缩</span></span><br><span class="line">            p[x] = find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        <span class="comment">// 并查集的初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i ++)&#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m -- != <span class="number">0</span>)&#123;</span><br><span class="line">            String s = sc.next();</span><br><span class="line">            <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;M&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="comment">// 如果已经在同一个集合就不需要操作</span></span><br><span class="line">                <span class="keyword">if</span>(find(a) == find(b))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 改变集合大小(只改变根结点的值)</span></span><br><span class="line">                size[find(b)] += size[find(a)];</span><br><span class="line">                <span class="comment">// 合并两个集合</span></span><br><span class="line">                p[find(a)] = find(b);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 判断两个数是否在同一个集合</span></span><br><span class="line">                <span class="keyword">if</span>(find(a) != find(b))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初等数论</title>
      <link href="2021/07/07/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"/>
      <url>2021/07/07/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>ps：待更新</strong></p><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h3 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>质数（素数）指的是<strong>严格大于1的只包含1和本身两个约数的数</strong></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>由于约数是两两成对    所以只需要枚举到本身的根号阶    即可判断出结果</p><p><strong>循环条件可选写法</strong></p><ol><li><p>i * i &lt;= n</p><p> 如果n接近于int型最大值    那么i * i 有可能会溢出变成负数    影响判定结果</p></li><li><p>使用函数</p><p> 每次判断时都要调用函数耗时久</p></li><li><p>i &lt;= n / i (推荐写法)</p><p> 不会溢出</p></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试除法判定素数</span></span><br><span class="line"><span class="comment">// 注意这里的优化细节</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / i ; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="分解质因子"><a href="#分解质因子" class="headerlink" title="分解质因子"></a>分解质因子</h3><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）从2开始枚举</p><p>（2）每次找到质因子后计算质因子的个数时 都会将n缩小，即将算到的质因子去除，更新后n不会再有此质因子</p><p>所以</p><ol><li>可以直接从0枚举 到n / i，不用考虑n % i == 0的 i 可能是合数的问题，因为每次都将之前的质因子去掉了</li><li>算法的时间复杂度不一定就是O(sqrt(n)) 即根号阶，因为可能在过程中n缩小了，降低了判断次数，最好情况下的时间复杂度为O(logn)</li></ol><p>（3）n中只可能有一个大于sqrt(n)的质因子    （如果有多于一个，则相乘大于n，矛盾了）</p><p>这个质因子只可能是    循环完成后    去除了其他质因子的n</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                s ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;,&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(n + <span class="string">&quot;,&quot;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛选质数"><a href="#筛选质数" class="headerlink" title="筛选质数"></a>筛选质数</h3><h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>每次把当前 <strong>i</strong> 的倍数筛除，只有质数才会满足 <strong>if</strong> 条件</p><p>只需要筛除质数的倍数即可，因为合数的倍数已经被合数的最小质因子给筛除了</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>质数定理：1到N中，有 N/lnN 个质数</p><p>理论上时间复杂度为O(n)，实际情况为O(nloglogn);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">1000001</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] primes = <span class="keyword">new</span> primes[N];</span><br><span class="line"><span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">            primes[count ++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">                flag[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>每一个合数只会被它的最小质因子筛除</strong></p><ol><li>当 for 中if成立时，说明 p[j] 是 i 的最小质因子，所以p[j]也是p[j]  * i 的最小质因子，这样就筛除了p[j] * i</li><li>当 for 中if不成立时，说明 p[j] 小于 i 的最小质因子，所以p[j]是p[j]  * i 的最小质因子，这样同样筛除了p[j] * i</li></ol><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><p>第二重的循环中循环条件不需要 j &lt; count 的原因</p><ol><li>当 i 为合数时，必定出现 i % primes[j] == 0，所以会直接退出</li><li>当 i 为质数时，必定出现 i == primes[j]，所以也会在最后一次循环中退出，因为循环之前已经将 i 加入了primes数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count为质数的数量</span></span><br><span class="line"><span class="keyword">int</span> N = <span class="number">1000001</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//用于装载所有已经被判断出来的质数</span></span><br><span class="line"><span class="keyword">int</span>[] primes = <span class="keyword">new</span> primes[N];</span><br><span class="line"><span class="comment">//判断对应下标是否为合数，合数则赋值为true</span></span><br><span class="line"><span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">            primes[count ++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++)&#123;</span><br><span class="line">        flag[primes[j] * i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        <span class="comment">// 边界情况，是平方的时候只需要加一次</span></span><br><span class="line">        <span class="keyword">if</span>(i != n / i)&#123;</span><br><span class="line">            list.add(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p><strong>N = P<del>1</del>^a1^ +  P<del>2</del>^a2^ +  P<del>3</del>^a3^  + ······ +  P<del>n</del>^an^</strong></p><p>则约数个数为**(a^1^ + 1) * (a^2^ + 1) * (a^3^ + 1) * ······ * (a^n^ + 1)**</p><p>N 的约数展开式形式与 N 相同    区别在于约数展开式对于每一个 <strong>P<del>i</del>^ai^</strong>， **ai范围在(0,ai)，共ai + 1 种可能性 **</p><h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><p><strong>N = P<del>1</del>^a1^ +  P<del>2</del>^a2^ +  P<del>3</del>^a3^  + ······ +  P<del>n</del>^an^</strong></p><p>则约数之和为**(p<del>1</del>^0^ + p<del>1</del>^1^ + ··· + p<del>1</del>^a1^)···(p<del>n</del>^0^ + p<del>n</del>^1^ + ··· + p<del>n</del>^an^)**</p><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>欧几里得定理（辗转相除法）:    <strong>gcd(a, b) == gcd (b, a % b)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b != <span class="number">0</span> ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><p><strong>N = P<del>1</del>^a1^ +  P<del>2</del>^a2^ +  P<del>3</del>^a3^  + ······ +  P<del>n</del>^an^</strong></p><p>则 1 到 N 中 与 N 互质的数有     <strong>N (1 - 1 / p1) (1 - 1 / p2) ··· (1- 1 / pn)</strong>     个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里注意怎么防止出现小数</span></span><br><span class="line">        res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="线性筛法求欧拉函数和"><a href="#线性筛法求欧拉函数和" class="headerlink" title="线性筛法求欧拉函数和"></a>线性筛法求欧拉函数和</h3><blockquote><p>给定一个正整数 n，求 1∼n 中每个数的欧拉函数之和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1000001</span>, size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] prime = <span class="keyword">new</span> <span class="keyword">int</span>[N], phi = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) &#123;</span><br><span class="line">            prime[size ++] = i;</span><br><span class="line">            <span class="comment">// 质数的欧拉函数值为本身减一</span></span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j ++) &#123;</span><br><span class="line">            f[prime[j] * i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// prime[j]是i的质数，则phi[prime[j] * i]和phi[i] 只相差一个prime[j]</span></span><br><span class="line">                phi[prime[j] * i] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// prime[j]是i的质数，则phi[prime[j] * i]和phi[i] 相差 prime[j] * (1 - 1 / prime[j])</span></span><br><span class="line">            phi[prime[j] * i] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        res += phi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 a 与 n 互质, d(n) 为欧拉函数， 则 <strong>a^d(n)^ mod n 同余于 1</strong></p><p>例 ： a = 5 ， n = 6         a^d(n)^  mod 6    =    5^d(6)^ % 6    =    25 % 6    =    1    = 1 % n</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若 n 为质数，a 与 n 互质， 则 <strong>a^n-1^ mod n 同余于 1</strong></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> ctr = a;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = (ctr * res) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        ctr = (ctr * ctr) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(res % p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h3><p><strong>a * a^-1^ 同余于 p</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> ctr = a;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = (ctr * res) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        ctr = (ctr * ctr) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(res % p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">     <span class="keyword">while</span>(n -- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt(), p = sc.nextInt();</span><br><span class="line">        <span class="comment">// a 与 p 互质，才有乘法逆元</span></span><br><span class="line">        <span class="keyword">if</span>(a % p != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(get(a, p - <span class="number">2</span>, p));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p> 对于任意正整数 a , b ，一定存在非零整数 x ， y ，使得 ax + by = (a,b) （ a 和 b 的最大公约数）</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><blockquote><p>给定 n 对正整数 a<del>i</del>,b<del>i</del>，对于每对数，求出一组 x<del>i</del>,y<del>i</del>，使其满足 <strong>a<del>i</del> * x<del>i</del> + b<del>i</del> * y<del>i</del>    =    gcd(a<del>i</del>,b<del>i</del>)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x , y;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b);</span><br><span class="line">    <span class="comment">// 交换 x,y的值 因为每次辗转相除 a和b的相对位置会改变</span></span><br><span class="line">    <span class="keyword">int</span> t = y;</span><br><span class="line">    y = x;</span><br><span class="line">    x = t;</span><br><span class="line"></span><br><span class="line">    y -= a/ b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><blockquote><p>给定 n 组数据 a,b,m    对于每组数求出一个 x，使其满足 a * x ≡ b (mod m)，如果无解则输出 <code>impossible</code></p></blockquote><p>思路先将题目中同余转换为 ax - my = b<br>这就是扩展欧几里得的形式<br>根据扩展欧几里得 ax + m(-y) = d 算出d和x（顺带算出y）<br>得到的x乘上b / d % m 就是结果</p><p><strong>无解的情况在于    b 必须是 d的倍数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x , y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得模板</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b);</span><br><span class="line">    <span class="comment">// 交换 x,y的值 因为每次辗转相除 a和b的相对位置会改变</span></span><br><span class="line">    <span class="keyword">int</span> t = y;</span><br><span class="line">    y = x;</span><br><span class="line">    x = t;</span><br><span class="line">    y -= a/ b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">    <span class="keyword">while</span>(n -- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> d = exgcd(a,m);</span><br><span class="line">        <span class="comment">// 这里是因为扩展欧几里得有解的充分必要条件 b要能整除(a,m)的最大公约数 也就是b能整除d</span></span><br><span class="line">        <span class="keyword">if</span>(b % d != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println((<span class="keyword">long</span>)x * (b / d) % m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><blockquote><p>二进制枚举选取集合<br>t（选取的数的乘积） 可能爆int，使用long long判断是否大于n，大于n直接结束此次循环</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原题链接：https://www.acwing.com/problem/content/892/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span>((ll)t * p[j] &gt; n) &#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t *= p[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">2</span>) res += n / t;</span><br><span class="line">            <span class="keyword">else</span> res-= n / t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 质数 </tag>
            
            <tag> 约数 </tag>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 快速幂 </tag>
            
            <tag> 逆元 </tag>
            
            <tag> 裴蜀定理 </tag>
            
            <tag> 扩展欧几里得 </tag>
            
            <tag> 中国剩余定理 </tag>
            
            <tag> 高斯消元 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2021/05/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/05/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><strong>每件物品只能选择一次</strong></p><blockquote><p>f[i][j]表示从前 i 件物品中选，总体积最大为 j 可以选出的最大价值</p><p>v[i]是第 i 件物品的体积</p><p>w[i]是第 i 件物品的价值</p><p>状态划分</p><p>f[i][j]划分为 <code>没有选择第 i 个物品</code>和<code>选择了第 i 个物品</code></p><p><strong>状态转移方程</strong></p><p>f[i][j] = Math.max(<code>f[i - 1][j] </code>, <code>f[i - 1][j - v[i]] +  w[i]</code>)</p><p><strong>一维优化</strong></p><p>注意点</p><p>由于只与 i 只与 上一层 i - 1有关，所以可以直接删去第一维</p><p>但是注意取最大值时的<code>f[j - v[i]]</code>等价的是<code>f[i][j - v[i]]</code>， 而不是<code>f[i - 1][j - v[i]]</code></p><p>原因是计算第 i 层时，已经将 j - v[i]  更新过了，而我们要的是第i - 1层的（也就是没有被更新过的）,所以f[j - v[i]]已经在了第 i 层</p><p>解决办法就是从大到小枚举 j </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维朴素做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j ++)&#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="comment">// 只有当背包容量能装下第i个物品的时候，才能出现第二种情况</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维优化做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= v[i]; j --)&#123;</span><br><span class="line">        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><strong>每件物品可无限制挑选</strong></p><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210527092453.png" alt="image-20210505153056539"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三维朴素做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k ++)&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维优化做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j ++)&#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="comment">// 只有当背包容量能装下第i个物品的时候，才能出现第二种情况</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维优化做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= V; j ++)&#123;</span><br><span class="line">        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><strong>每种物品有数量限制</strong></p><blockquote><p>每种物品的数量用数组s 存储</p><p>朴素做法与完全背包的朴素做法只多一个限制条件</p><p>k循环时判断条件多一个k &lt;= s[i]</p></blockquote><blockquote><p><strong>二进制优化</strong></p><p>本质上就是将每种物品打包成多种物品</p><p>将朴素做法中从0到k件物品中选物品 —&gt;    每件物品选0到1次（01背包）</p><p>优化过程需要logn的时间复杂度    去掉了原本O(k)的复杂度</p><p>最终物品数量不是n,而是cnt</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三维朴素做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k ++)&#123;</span><br><span class="line">            f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">int</span> a = sc.nextInt(), b = sc.nextInt(), s = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= s)&#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        v[cnt] = a * k;</span><br><span class="line">        w[cnt] = b * k;</span><br><span class="line">        s -= k;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        v[cnt] = a * s;</span><br><span class="line">        w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">N = cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= v[i]; j --)&#123;</span><br><span class="line">        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><strong>物品分为多组，每组中有多种物品，每组最多选一种物品</strong></p><blockquote><p>本质上也是01背包，只不过要枚举每一组中物品，多一层O(k)，并且体积和价值要按组存储</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k  = <span class="number">0</span>; k &lt; s[i]; k ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][k] &lt;= j)&#123;</span><br><span class="line">                f[j] = Math.max(f[j], f[j - v[i][k]] + w[i][k]); </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210527092852.png" alt="image-20210507223317859"></p><p><strong>自底向上考虑,每一个位置的最大路径为其下两个位置的最大值加上自身值，最下面的最大值即为本身</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最下面一行最大值为自身</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">    dp[j] = nums[n - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">        dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + nums[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><blockquote><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少（子序列可以不连续）</p></blockquote><p><strong>f[i]</strong> 表示以第 i 个元素结尾的最长子序列</p><p>ps : 要想记录路径，就用一个数组记录每个 f[i] 是由哪一个 j 转移过来的即可，就是在取最大值的时候记录一下 j </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n2)</span></span><br><span class="line"><span class="comment">// 如果数据范围可能为0，在前面特判一下即可</span></span><br><span class="line">res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">            max = Math.max(res[j] + <span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    max = Math.max(max, res[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调优化O(nlogn)</span></span><br><span class="line"><span class="comment">// 输入数据</span></span><br><span class="line"><span class="keyword">int</span>[] a = nw <span class="keyword">int</span>[n];</span><br><span class="line"><span class="comment">// q[i]存的是长度为 i 的最长上升子序列的结尾的最小值</span></span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    a[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = -<span class="number">2000000000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    <span class="comment">// 从0 到 当前最大长度区间中寻找</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q[mid] &lt; a[i])&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新当前最大长度</span></span><br><span class="line">    len = Math.max(len, r + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 更新最小值</span></span><br><span class="line">    q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(len);</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><blockquote><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少</p></blockquote><p><strong>f[i][j]</strong> 表示从第一个序列前 i 个字符和第二个序列前 j 个字符中最长的公共子序列</p><p><strong>f[i][j]</strong> 根据是否含有num1[i]  和 num2[j] 可分成四种情况</p><p>分别为<strong>f[i - 1][j  -  1]</strong>    <strong>f[i - 1][j]</strong>    <strong>f[i][j - 1]</strong>    <strong>f[i - 1][j - 1] + 1</strong>    求这4种情况的最大值即可</p><p>注意    中间两种情况并不是对应着是否有num1[i]  和 num2[j]</p><p>只是因为这里求的是最大值，<strong>f[i - 1][j]</strong>    <strong>f[i][j - 1]</strong> 将这两种情况将覆盖了，求最大值可以达到同样的效果</p><p>同时注意到    <strong>f[i - 1][j]</strong>    <strong>f[i][j - 1]<strong>不仅是将第二种和第三种情况覆盖了，其实也把第一种情况覆盖了，所以是不用计算</strong>f[i - 1][j  -  1]</strong></p><p>还需要注意的是，虽然第四种情况是一定大于第一种情况的，但是如果num1[i]  和 num2[j]不相同的话是不存在第四种情况的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p><strong>f[i][j]</strong> 存的是 将 a 的前 i 个字母组成的字符串    变成    b 的前 i 个字母组成的字符串</p><p><strong>f[i][j]</strong> 可以被分为三类</p><p>1.删除</p><p><strong>f[i][j] = f[i - 1][j] + 1</strong></p><p>2.添加</p><p><strong>f[i][j] = f[i][j - 1] + 1</strong></p><p>3.替换</p><p>如果<strong>a[i] == b[j]</strong>     则<strong>f[i][j] = f[i - 1][j - 1]</strong></p><p>如果<strong>a[i] != b[j]</strong>     则<strong>f[i][j] = f[i - 1][j - 1] + 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">String a = sc.next();</span><br><span class="line"><span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">String b = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">        f[i][j] = Math.min(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(i - <span class="number">1</span>) == b.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">            f[i][j] = Math.min(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f[i][j] = Math.min(f[i][j] , f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间类DP"><a href="#区间类DP" class="headerlink" title="区间类DP"></a>区间类DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><blockquote><p>给定几堆石子，每次只能合并相邻的石子，代价为合并后石子的总重量，求石子合并为一堆的最小代价</p></blockquote><p><strong>f[i][j]</strong>    表示从第 i 堆石子到第 j 堆石子合并为一堆的最小代价</p><p><img src="https://gitee.com/amazing-feather/images/raw/master/20210527092704.png" alt="image-20210507231602167"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">        dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k ++)&#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><blockquote><p> 类比完全背包    总体积为 n ， 有 n 个物品， 价值分别为 1 到 n</p><p> <strong>f[i][j]</strong> 表示 从前 i 个物品中选，总和等于为 n 的方案数</p></blockquote><p><strong>f[i][j] == f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i]  + … + + f[i - 1][j - s * i]</strong>        (朴素转移方程)</p><p><strong>f[i][j - i] ==               f[i - 1][j - i] + f[i - 1][j - 2i]  + … + + f[i - 1][j - s * i]</strong></p><p>由上面两式推得    <strong>f[i][j] == f[i - 1][j] + f[i][j - i]</strong>(二维最简优化)</p><p>​                               <strong>f[j] == f[j] + f[j - i]</strong>(一维最简优化)</p><blockquote><p><strong>f[i][j]</strong> 表示 总和为 i ，恰好是由 j 个数组成的方案数</p></blockquote><p><strong>f[i][j]</strong> 可以分为两类</p><p>1.最小值为1</p><p><strong>f[i - 1][j - 1]</strong></p><p>2.最小值大于1</p><p><strong>f[i - j][j]</strong></p><p>推得    <strong>f[i][j] = f[i - 1][j - 1] + f[i - j][j]    (注意 ： f[0][0] == 1)</strong> </p><p>答案为    <strong>f[n][1] + f[n][2] + … + f[n][n]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包思路</span></span><br><span class="line"><span class="comment">// 一个数都不选是一种方案</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j ++)&#123;</span><br><span class="line">        f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><blockquote><p>未优化版</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> v[N][M];</span><br><span class="line"><span class="keyword">bool</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m , n || m) &#123;</span><br><span class="line">        <span class="comment">// 多组测试用例，所以要初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="comment">// 预处理出来每种二进制态是否连续为偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++) &#123;</span><br><span class="line">            f[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) f[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) f[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m ; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++) &#123;</span><br><span class="line">                    <span class="comment">// j 是第 i 列的状态，k 是第 i - 1列的状态，j 和 k不能相交，如果为 1，则说明i - 2列伸到了i - 1列，而 i - 1列又伸到了 i 列，这种情况是不合法的</span></span><br><span class="line">                    <span class="comment">// j | k 是根据j 和 k两种状态看第 i - 1 列是否伸出来（占用），然后判断这种状态下是否合法</span></span><br><span class="line">                    <span class="comment">// 对于某一行来说</span></span><br><span class="line">                    <span class="comment">// k == 0 j == 0说明i - 1列没有占用所以为 0</span></span><br><span class="line">                    <span class="comment">// k == 0 j == 1j状态占用了 i - 1 和 i   所以为 1</span></span><br><span class="line">                    <span class="comment">// k == 1 j == 0k状态占用了 i - 2 和 i - 1  所以为 1</span></span><br><span class="line">                    <span class="comment">// j | k 或者 j ^ k 都可以，因为 j 和 k 不能同时为 1 ，而其他情况下这两个运算结果是一样的</span></span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; f[j | k]) &#123;</span><br><span class="line">                        v[i][j] += v[i - <span class="number">1</span>][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优化版</p><p>不同每次暴力枚举 k</p><p>而是对于每个 j ，一开始就预处理出与其合法的 k</p><p>然后状态转移的时候直接用就行</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> v[N][M];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; state[M];</span><br><span class="line"><span class="keyword">bool</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m , n || m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="comment">// 预处理出来每种二进制态是否连续为偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++) &#123;</span><br><span class="line">            f[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) f[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) f[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++) &#123;</span><br><span class="line">            <span class="comment">// 注意清空，因为有多组数据</span></span><br><span class="line">            state[j].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; f[j | k]) &#123;</span><br><span class="line">                    state[j].<span class="built_in">push_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m ; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++) &#123;</span><br><span class="line">                <span class="comment">// for(int k = 0; k &lt; 1 &lt;&lt; n; k ++) &#123;</span></span><br><span class="line">                <span class="comment">//     if((j &amp; k) == 0 &amp;&amp; f[j ^ k]) &#123;</span></span><br><span class="line">                <span class="comment">//         v[i][j] += v[i - 1][k];</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; state[j].<span class="built_in">size</span>(); k ++) &#123;</span><br><span class="line">                    v[i][j] += v[i - <span class="number">1</span>][state[j][k]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">int</span> dist[N][N], v[M][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j ++) &#123;</span><br><span class="line">            cin &gt;&gt; dist[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    v[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++) &#123;</span><br><span class="line">                    <span class="comment">// 除去j点之后，k的状态必须是1才有意义</span></span><br><span class="line">                    <span class="keyword">if</span>(i - (<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        v[i][j] = <span class="built_in">min</span>(v[i][j], v[i - (<span class="number">1</span> &lt;&lt; j)][k] + dist[j][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><blockquote><p>原题链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjg3Lw==">https://www.acwing.com/problem/content/287/<i class="fa fa-external-link-alt"></i></span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// f[i][0]表示不选这个节点的最大值， f[i][1]表示选了这个节点的最大值</span></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>], happy[N];</span><br><span class="line"><span class="comment">// 判断每个点是否有父节点，没有父节点就是是 根节点</span></span><br><span class="line"><span class="keyword">bool</span> has_father[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(b);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[b][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[b][<span class="number">0</span>], f[b][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; happy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root]) root ++;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">1</span>], f[root][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><blockquote><p>原题链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTAzLw==">https://www.acwing.com/problem/content/903/<i class="fa fa-external-link-alt"></i></span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N][N], h[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[a][b];</span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="comment">// 注意v最小值是 1</span></span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a + dx[i], y = b + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; h[a][b] &gt; h[x][y]) &#123;</span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(x, y) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m ; j ++) &#123;</span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m ; j ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><blockquote><p>饿汉式：类加载的时候就创建出实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">弊端：</span></span><br><span class="line"><span class="comment">即使此单例不需要使用，它也会在类加载后创建出来。占用内存，并增加类的初始化时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的初始化的时候就创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造设为private，防止其他类通过构造方法实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过该静态方法才可获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><blockquote><p>懒汉式：先声明一个空变量，需要使用的时候才创建实例</p></blockquote><p><strong>双检锁方式实现懒汉式单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重排序使用volatile关键字</span></span><br><span class="line">    <span class="comment">// 重排序会在特殊情况下导致线程不安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证其他类无法通过构造方法创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 不加这个判空，则每次都要加锁，影响性能</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 加锁保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">                <span class="comment">// 这里不加判空同样可能存在多次创建实例的情况</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类实现懒汉式单例</strong></p><p>内部类是在使用时才会加载，所以可以实现懒加载</p><p>虚拟机底层是保证了类加载的时候是线程安全的，所以在懒加载创建实例的时候一定是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> StaticLazy instance = <span class="keyword">new</span> StaticLazy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticLazyHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式</p><p>对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>最终版抽象工厂模式</strong></p><p>总接口，所有的工厂类都必须实现此接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Factory接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供创建实例的方法</span></span><br><span class="line">    <span class="function">Fruit <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂类可以封装（创建类实例时的）细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 苹果工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 封装创建时的具体细节</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这是最终版本的抽象工厂模式</span></span><br><span class="line"><span class="comment">   优点：</span></span><br><span class="line"><span class="comment">   想要修改创建的具体工厂类，只需要改一行代码即可实现，修改之后调用的方法随之改变成对应的工厂实现</span></span><br><span class="line"><span class="comment">   缺点：</span></span><br><span class="line"><span class="comment">   如果Factory接口需要新增功能，会影响到所有具体的工厂类</span></span><br><span class="line"><span class="comment">   所以只适合增加同类具体工厂，而不适合新增功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建苹果</span></span><br><span class="line"> Factory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"><span class="comment">// 直接调用接口提供的方法，不用知道具体细节</span></span><br><span class="line"> Fruit apple = appleFactory.create();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建梨子</span></span><br><span class="line"> Factory pearFactory = <span class="keyword">new</span> PearFactory();</span><br><span class="line"><span class="comment">// 直接调用接口提供的方法，不用知道具体细节</span></span><br><span class="line"> Fruit peat = pearFactory.create();</span><br></pre></td></tr></table></figure><h2 id="建造型模式"><a href="#建造型模式" class="headerlink" title="建造型模式"></a>建造型模式</h2><p>建造型模式用于创建过程稳定，但配置多变的对象</p><p><strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示</strong></p><p>好处在于不会忘记指定配置，保证构建的过程是稳定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 口味类型</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="comment">// 大杯 中杯</span></span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">    <span class="comment">// 是否加珍珠</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> pearl;</span><br><span class="line">    <span class="comment">// 是否加冰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPearl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pearl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MilkTea</span><span class="params">(MilkTeaBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = builder.type;</span><br><span class="line">        <span class="keyword">this</span>.size = builder.size;</span><br><span class="line">        <span class="keyword">this</span>.pearl = builder.pearl;</span><br><span class="line">        <span class="keyword">this</span>.ice = builder.ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MilkTea&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;type=&#x27;&quot;</span> + type + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, size=&#x27;&quot;</span> + size + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pearl=&quot;</span> + pearl +</span><br><span class="line">                <span class="string">&quot;, ice=&quot;</span> + ice +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建造者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTeaBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> String size;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> pearl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MilkTeaBuilder</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">size</span><span class="params">(String size)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">pearl</span><span class="params">(<span class="keyword">boolean</span> pearl)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pearl = pearl;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTeaBuilder <span class="title">ice</span><span class="params">(<span class="keyword">boolean</span> ice)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ice = ice;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MilkTea <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MilkTea(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户建造一杯奶茶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MilkTea milkTea = <span class="keyword">new</span> MilkTea.MilkTeaBuilder(<span class="string">&quot;蓝莓味&quot;</span>)</span><br><span class="line">    .size(<span class="string">&quot;大杯&quot;</span>)</span><br><span class="line">    .pearl(<span class="keyword">true</span>)</span><br><span class="line">    .ice(<span class="keyword">false</span>)</span><br><span class="line">    .Builder();</span><br><span class="line">System.out.println(milkTea);</span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>其实就是给对象提供一个clone方法克隆出新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 口味类型</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="comment">// 是否加冰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    克隆当前实例</span></span><br><span class="line"><span class="comment">    ps： 如下重写clone方法是无法克隆非基本类型的（会直接引用当前的）（浅拷贝），需要自行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MilkTea <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MilkTea) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式适用于有<strong>相关性但不兼容的结构</strong>，源接口通过一个中间件（适配器）转换后才可以适用于目标接口</p><p>下面是usb用家庭电源充电的例子</p><p>家庭电源的提供的电压是220V，但是USB只能适用用5V的输入，这样我们就必须将家庭电源提供的220V转换成5V以给USB使用，所以这中间要多一次转换电压的操作，这个操作就是用适配器来完成</p><p><strong>家庭电源提供220V电压</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeBattery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供220V电压</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">supply</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>USB充电</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(<span class="keyword">int</span> volt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (volt != <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;只能接收5V的电压&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适配器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适配</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">convert</span> <span class="params">(<span class="keyword">int</span> homevolt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chargeVolt = homevolt - <span class="number">215</span>;</span><br><span class="line">        <span class="keyword">return</span> chargeVolt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用户给USB充电</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 充电测试</span></span><br><span class="line">        chargeForPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chargeForPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        HomeBattery homeBattery = <span class="keyword">new</span> HomeBattery();</span><br><span class="line">        <span class="comment">// 家庭电源的提供的电压</span></span><br><span class="line">        <span class="keyword">int</span> homeVolt = homeBattery.supply();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 适配</span></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        <span class="keyword">int</span> chargeVolt = adapter.convert(homeVolt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 充电</span></span><br><span class="line">        USBLine usbLine = <span class="keyword">new</span> USBLine();</span><br><span class="line">        usbLine.charge(chargeVolt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行输出：正在充电</p><p>如果没有做适配，运行会报错，错误信息：只能接收5V的电压</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。主要用于多个同等级的接口</p><p>比如下面例子，形状和颜色的组合</p><p><strong>颜色接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IColor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的颜色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span>  <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绿</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>形状接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在具体的形状类当中桥接颜色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">IShape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(IColor color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个&quot;</span> + color.getColor() +<span class="string">&quot;色的矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> <span class="keyword">implements</span> <span class="title">IShape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(IColor color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一个&quot;</span> + color.getColor() +<span class="string">&quot;色的圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    rectangle.setColor(<span class="keyword">new</span> Green());</span><br><span class="line">    rectangle.draw();</span><br><span class="line"></span><br><span class="line">    Cycle cycle = <span class="keyword">new</span> Cycle();</span><br><span class="line">    cycle.setColor(<span class="keyword">new</span> Red());</span><br><span class="line">    cycle.draw();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出</p><p>一个绿色的矩形<br>一个红色的圆形</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
